import { Octokit } from '@octokit/rest';
import { PRContext, FileChange } from '../types';
import logger from '../utils/logger';

export class GitHubClient {
  private octokit: Octokit;
  private owner: string;
  private repo: string;

  constructor() {
    this.octokit = new Octokit({
      auth: process.env.GITHUB_TOKEN,
    });
    this.owner = process.env.GITHUB_REPO_OWNER || '';
    this.repo = process.env.GITHUB_REPO_NAME || '';
  }

  async createPullRequest(
    branchName: string,
    baseBranch: string,
    title: string,
    body: string
  ): Promise<number> {
    try {
      const response = await this.octokit.pulls.create({
        owner: this.owner,
        repo: this.repo,
        title,
        head: branchName,
        base: baseBranch,
        body,
      });

      logger.info('Pull request created', {
        number: response.data.number,
        title,
      });

      return response.data.number;
    } catch (error) {
      logger.error('Failed to create pull request', { error, branchName });
      throw error;
    }
  }

  async generatePRDescription(context: PRContext, taskDescription: string): Promise<string> {
    const sections: string[] = [];

    // Title section
    sections.push(`## Summary\n\n${taskDescription}\n`);

    // Changes section
    sections.push('## Changes\n');
    const changesByType = this.groupChangesByType(context.changes);

    if (changesByType.added.length > 0) {
      sections.push('### Added');
      changesByType.added.forEach((file) => sections.push(`- ${file.path}`));
      sections.push('');
    }

    if (changesByType.modified.length > 0) {
      sections.push('### Modified');
      changesByType.modified.forEach((file) => sections.push(`- ${file.path}`));
      sections.push('');
    }

    if (changesByType.deleted.length > 0) {
      sections.push('### Deleted');
      changesByType.deleted.forEach((file) => sections.push(`- ${file.path}`));
      sections.push('');
    }

    // Impact analysis
    if (context.impactAnalysis) {
      sections.push(`## Impact Analysis\n\n${context.impactAnalysis}\n`);
    }

    // Test results
    if (context.testResults && context.testResults.length > 0) {
      sections.push('## Test Results\n');
      sections.push(`âœ… ${context.testResults.length} tests passed\n`);
    }

    // Performance metrics
    if (context.performanceMetrics) {
      sections.push('## Performance Metrics\n');
      sections.push('```json');
      sections.push(JSON.stringify(context.performanceMetrics, null, 2));
      sections.push('```\n');
    }

    // Security scan
    if (context.securityScan) {
      sections.push('## Security Scan\n');
      sections.push('```json');
      sections.push(JSON.stringify(context.securityScan, null, 2));
      sections.push('```\n');
    }

    // Footer
    sections.push('---');
    sections.push('*ðŸ¤– This PR was automatically generated by FabAI Slack Bot*');

    return sections.join('\n');
  }

  private groupChangesByType(changes: FileChange[]): {
    added: FileChange[];
    modified: FileChange[];
    deleted: FileChange[];
  } {
    return {
      added: changes.filter((c) => c.type === 'added'),
      modified: changes.filter((c) => c.type === 'modified'),
      deleted: changes.filter((c) => c.type === 'deleted'),
    };
  }

  async addReviewers(prNumber: number, reviewers: string[]): Promise<void> {
    try {
      await this.octokit.pulls.requestReviewers({
        owner: this.owner,
        repo: this.repo,
        pull_number: prNumber,
        reviewers,
      });

      logger.info('Reviewers added to PR', { prNumber, reviewers });
    } catch (error) {
      logger.error('Failed to add reviewers', { error, prNumber });
      throw error;
    }
  }

  async addLabels(prNumber: number, labels: string[]): Promise<void> {
    try {
      await this.octokit.issues.addLabels({
        owner: this.owner,
        repo: this.repo,
        issue_number: prNumber,
        labels,
      });

      logger.info('Labels added to PR', { prNumber, labels });
    } catch (error) {
      logger.error('Failed to add labels', { error, prNumber });
      throw error;
    }
  }

  async addComment(prNumber: number, comment: string): Promise<void> {
    try {
      await this.octokit.issues.createComment({
        owner: this.owner,
        repo: this.repo,
        issue_number: prNumber,
        body: comment,
      });

      logger.info('Comment added to PR', { prNumber });
    } catch (error) {
      logger.error('Failed to add comment', { error, prNumber });
      throw error;
    }
  }

  async mergePullRequest(prNumber: number, mergeMethod: 'merge' | 'squash' | 'rebase' = 'squash'): Promise<void> {
    try {
      await this.octokit.pulls.merge({
        owner: this.owner,
        repo: this.repo,
        pull_number: prNumber,
        merge_method: mergeMethod,
      });

      logger.info('Pull request merged', { prNumber, mergeMethod });
    } catch (error) {
      logger.error('Failed to merge pull request', { error, prNumber });
      throw error;
    }
  }

  async closePullRequest(prNumber: number): Promise<void> {
    try {
      await this.octokit.pulls.update({
        owner: this.owner,
        repo: this.repo,
        pull_number: prNumber,
        state: 'closed',
      });

      logger.info('Pull request closed', { prNumber });
    } catch (error) {
      logger.error('Failed to close pull request', { error, prNumber });
      throw error;
    }
  }

  async getPullRequest(prNumber: number) {
    try {
      const response = await this.octokit.pulls.get({
        owner: this.owner,
        repo: this.repo,
        pull_number: prNumber,
      });

      return response.data;
    } catch (error) {
      logger.error('Failed to get pull request', { error, prNumber });
      throw error;
    }
  }

  async getCommits(branchName: string): Promise<any[]> {
    try {
      const response = await this.octokit.repos.listCommits({
        owner: this.owner,
        repo: this.repo,
        sha: branchName,
      });

      return response.data;
    } catch (error) {
      logger.error('Failed to get commits', { error, branchName });
      throw error;
    }
  }
}
